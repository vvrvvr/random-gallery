<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Gallery</title>

<style>
  *, *::before, *::after {
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
  }

  body {
    margin: 0;
    padding: 20px;
    font-family: Arial, sans-serif;
    background: #fff;
    overflow: hidden; /* галерея должна помещаться в окно без скролла */
  }

  body.modal-open {
    overflow: hidden; /* не показывать скролл и не прокручивать страницу под оверлеем */
  }

  :root {
    --gap: 1px;
    --tile: clamp(140px, 18vw, 220px);
  }

  /* Adaptive mosaic grid (Yandex Disk-ish) */
  #gallery {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--tile), 1fr));
    /* Fill the viewport height with photos (no big empty area at the bottom) */
    height: calc(100vh - 40px);
    grid-auto-rows: minmax(calc(var(--tile) * 0.75), 1fr);
    grid-auto-flow: dense;
    gap: var(--gap);
    align-content: stretch;
    overflow: hidden;
  }

  .tile {
    position: relative;
    overflow: hidden;
  }

  .tile.wide {
    grid-column: span 2;
  }

  .tile.tall {
    grid-row: span 2;
  }

  /* Photo tile placeholder (shows instantly while images are loading) */
  .tile.photo {
    background: #eef1f5;
  }

  .tile.photo::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      90deg,
      rgba(255,255,255,0) 0%,
      rgba(255,255,255,0.55) 50%,
      rgba(255,255,255,0) 100%
    );
    transform: translateX(-100%);
    animation: shimmer 1.2s ease-in-out infinite;
    opacity: 0.7;
    pointer-events: none;
  }

  .tile.photo.loaded::before {
    display: none;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  /* Text tile (behaves like a tile, but isn't selectable / not part of overlay) */
  .tile.text {
    background: #f6f7f9;
    border: 1px solid rgba(0,0,0,0.08);
    padding: 16px 16px 14px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    gap: 10px;
    overflow: hidden;
    cursor: default;
  }

  .tile.text .text-title {
    margin: 0;
    font-size: 18px;
    line-height: 1.2;
    letter-spacing: 0.01em;
  }

  .tile.text .text-body {
    margin: 0;
    font-size: 14px;
    line-height: 1.45;
    color: rgba(0,0,0,0.74);
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
  }

  img.thumb {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 0;
    cursor: pointer;
    display: block;
    opacity: 0;
    filter: blur(18px);
    transform: scale(1.03);
    transition: opacity 220ms ease, filter 260ms ease, transform 260ms ease;
    will-change: opacity, filter, transform;
  }

  img.thumb.loaded {
    opacity: 1;
    filter: blur(0);
    transform: scale(1);
  }

  @media (max-width: 420px) {
    #gallery {
      grid-template-columns: 1fr;
      grid-auto-rows: clamp(160px, 48vw, 240px);
    }

    .tile.wide,
    .tile.tall {
      grid-column: span 1;
      grid-row: span 1;
    }
  }

  /* Overlay */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(20,20,20,0.95);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.18s ease;
    cursor: pointer; /* клик по фону закрывает */
  }

  .overlay.active {
    opacity: 1;
    visibility: visible;
  }

  /* Изображение */
  .overlay img {
    max-width: 95vw;
    max-height: 95vh;
    width: auto;
    height: auto;
    object-fit: contain;
    transform: scale(0.96);
    transition: transform 0.18s ease;
    cursor: default; /* клик по изображению НЕ закрывает */
    z-index: 1; /* ниже кнопок */
    box-shadow: 0 8px 22px rgba(0,0,0,0.28);
  }

  .overlay.active img {
    transform: scale(1);
  }

  /* Навигационные кнопки */
  .nav-btn {
    position: fixed; /* фиксируем относительно окна */
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 2.4rem;
    font-weight: bold;
    background: rgba(0,0,0,0.3);
    border: none;
    padding: 12px 18px;
    cursor: pointer;
    user-select: none;
    border-radius: 4px;
    z-index: 2; /* выше изображения */
  }

  .nav-btn:hover {
    background: rgba(255,255,255,0.2);
  }

  #prevBtn { left: 10px; }
  #nextBtn { right: 10px; }
</style>
</head>

<body>

<div id="gallery"></div>

<div class="overlay" id="overlay">
  <button class="nav-btn" id="prevBtn">&#10094;</button>
  <img id="overlayImg">
  <button class="nav-btn" id="nextBtn">&#10095;</button>
</div>

<script>
// Global set id (controlled in this file).
// Change this value (and redeploy) to roll a new stable "set" for all users of that deployed version.
const SET_ID = "default";

const imagesToShow = 10;
const IMAGES_DIR = "images";
const EXT = ".jpg";
const PROBE_MAX = 500; // upper bound for numbered images like 1.jpg..N.jpg
const PROBE_STOP_AFTER_MISSES = 25; // stop after N consecutive misses once we've found at least one
const PROBE_TIMEOUT_MS = 1800;

const overlay = document.getElementById("overlay");
const overlayImg = document.getElementById("overlayImg");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const gallery = document.getElementById("gallery");

let selectedImages = [];
let currentIndex = 0;
const tilesOnScreen = imagesToShow + 1; // 10 photos + 1 text tile

function lockPageScroll() {
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.body.classList.add("modal-open");
  if (scrollbarWidth > 0) {
    document.body.style.paddingRight = `${scrollbarWidth}px`;
  }
}

function unlockPageScroll() {
  document.body.classList.remove("modal-open");
  document.body.style.paddingRight = "";
}

function closeOverlay() {
  overlay.classList.remove("active");
  setTimeout(() => {
    if (!overlay.classList.contains("active")) {
      overlay.style.visibility = "hidden";
      unlockPageScroll();
    }
  }, 180); // совпадает с transition
}

// Render the grid structure immediately (placeholders), then fill images progressively.
const { wideSet: initialWideSet, tallSet: initialTallSet } = buildAccentSets(tilesOnScreen);
const photoSlots = [];

function createPhotoSlot(index, wideSet, tallSet) {
  const tile = document.createElement("div");
  tile.className = "tile photo";
  if (wideSet.has(index)) tile.classList.add("wide");
  else if (tallSet.has(index)) tile.classList.add("tall");

  const img = document.createElement("img");
  img.className = "thumb";
  img.alt = "";
  img.loading = "lazy";
  img.decoding = "async";

  tile.appendChild(img);
  gallery.appendChild(tile);
  return { tile, img };
}

function shuffle(arr, rnd = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rnd() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function fnv1a32(str) {
  // 32-bit FNV-1a hash
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}

function mulberry32(seed) {
  // Deterministic PRNG in [0,1)
  let a = seed >>> 0;
  return function () {
    a = (a + 0x6d2b79f5) >>> 0;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function getUserSeed() {
  // One seed per browser/profile (per origin). Used to keep layout stable on refresh,
  // while still being different across different users/browsers.
  const KEY = "myImages:userSeed";
  const existing = safeStorageGet(KEY);
  if (existing) return existing;

  let seed = "";
  try {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    seed = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
  } catch {
    seed = String(Date.now()) + ":" + String(Math.random());
  }

  safeStorageSet(KEY, seed);
  return seed;
}

function getStorageKey() {
  // localStorage is per-origin; add pathname so different pages don't conflict
  const path = (location.pathname || "/").replace(/\/$/, "");

  // Optional debug/testing override via URL, e.g. ?set=2
  // Different "set" values produce independent saved selections.
  const params = new URLSearchParams(location.search);
  const urlSet = (params.get("set") || "").trim();
  const set = (urlSet || SET_ID || "default").trim();

  return `myImages:${path || "/"}:set=${set}`;
}

function getLegacyStorageKey() {
  // Legacy key (before "set" support existed)
  const path = (location.pathname || "/").replace(/\/$/, "");
  return `myImages:${path || "/"}`;
}

function safeStorageGet(key) {
  try {
    return localStorage.getItem(key);
  } catch {
    return null;
  }
}

function safeStorageSet(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch {
    // ignore (private mode / disabled storage)
  }
}

async function probeImage(url) {
  // Fast existence check (works well on GitHub Pages).
  try {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), PROBE_TIMEOUT_MS);
    let res = await fetch(url, { method: "HEAD", signal: ctrl.signal, cache: "force-cache" });
    clearTimeout(t);

    // Some hosts may not support HEAD
    if (res.status === 405) {
      res = await fetch(url, { method: "GET", cache: "force-cache" });
    }

    return res.ok;
  } catch {
    // Fallback: image probe (older browsers / odd fetch failures)
    return await new Promise((resolve) => {
      const img = new Image();
      const t = setTimeout(() => {
        img.onload = null;
        img.onerror = null;
        resolve(false);
      }, PROBE_TIMEOUT_MS);

      img.onload = () => {
        clearTimeout(t);
        resolve(true);
      };
      img.onerror = () => {
        clearTimeout(t);
        resolve(false);
      };

      img.src = url;
    });
  }
}

async function getAvailableImageNumbers() {
  const found = [];
  let misses = 0;
  let foundAny = false;

  for (let i = 1; i <= PROBE_MAX; i++) {
    const ok = await probeImage(`${IMAGES_DIR}/${i}${EXT}`);
    if (ok) {
      found.push(i);
      foundAny = true;
      misses = 0;
    } else if (foundAny) {
      misses += 1;
      if (misses >= PROBE_STOP_AFTER_MISSES) break;
    }
  }

  return found;
}

function buildAccentSets(tilesOnScreen, rnd = Math.random) {
  const indices = Array.from({ length: tilesOnScreen }, (_, i) => i);
  shuffle(indices, rnd);

  const maxWide = Math.max(1, Math.round(tilesOnScreen * 0.2));
  const maxTall = Math.max(1, Math.round(tilesOnScreen * 0.15));
  const picked = indices.slice(0, Math.min(indices.length, maxWide + maxTall));

  return {
    wideSet: new Set(picked.slice(0, maxWide)),
    tallSet: new Set(picked.slice(maxWide)),
  };
}

function getOrCreateLayoutSets(storageKey, tilesOnScreen) {
  const key = `${storageKey}:layout`;
  const raw = safeStorageGet(key);
  if (raw) {
    try {
      const parsed = JSON.parse(raw);
      const wide = parsed && Array.isArray(parsed.wide) ? parsed.wide : null;
      const tall = parsed && Array.isArray(parsed.tall) ? parsed.tall : null;
      if (
        wide &&
        tall &&
        wide.every((n) => Number.isInteger(n) && n >= 0 && n < tilesOnScreen) &&
        tall.every((n) => Number.isInteger(n) && n >= 0 && n < tilesOnScreen)
      ) {
        return { wideSet: new Set(wide), tallSet: new Set(tall) };
      }
    } catch {
      // ignore
    }
  }

  const userSeed = getUserSeed();
  const seed = fnv1a32(`${userSeed}|${storageKey}|layout|${tilesOnScreen}`);
  const rnd = mulberry32(seed);
  const sets = buildAccentSets(tilesOnScreen, rnd);
  safeStorageSet(
    key,
    JSON.stringify({
      wide: Array.from(sets.wideSet),
      tall: Array.from(sets.tallSet),
    })
  );
  return sets;
}

function fillPhotoSlot(slot, num, index) {
  const { tile, img } = slot;
  img.classList.remove("loaded");
  tile.classList.remove("loaded");

  img.onload = () => {
    img.classList.add("loaded");
    tile.classList.add("loaded");
  };
  img.onerror = () => {
    // Keep placeholder if missing/broken.
    img.removeAttribute("src");
    img.classList.remove("loaded");
    tile.classList.remove("loaded");
  };

  img.src = `${IMAGES_DIR}/${num}${EXT}`;

  // Attach click only for real photos
  img.onclick = () => {
    currentIndex = index;
    overlayImg.src = img.src;
    overlay.classList.add("active");
    overlay.style.visibility = "visible";
    lockPageScroll();
  };
}

function createTextTile(index, wideSet, tallSet) {
  const tile = document.createElement("div");
  tile.className = "tile text";
  if (wideSet.has(index)) tile.classList.add("wide");
  else if (tallSet.has(index)) tile.classList.add("tall");

  const h = document.createElement("h3");
  h.className = "text-title";
  h.textContent = "Заметка";

  const p = document.createElement("p");
  p.className = "text-body";
  p.textContent =
    "Это текстовый блок примерно на 200 символов: он участвует в раскладке как обычная плитка, но не открывается в просмотрщике. Здесь можно писать описание, заметку или подпись к подборке снимков.";

  tile.appendChild(h);
  tile.appendChild(p);

  // Keep title size stable, but scale the note text down when the tile is smaller.
  const NOTE_BASE_PX = 14;
  const NOTE_MIN_PX = 10;
  const NOTE_STEP_PX = 0.5;

  function fitNoteText() {
    let size = NOTE_BASE_PX;
    p.style.fontSize = `${size}px`;

    let guard = 0;
    while (p.scrollHeight > p.clientHeight && size > NOTE_MIN_PX && guard < 30) {
      size = Math.max(NOTE_MIN_PX, size - NOTE_STEP_PX);
      p.style.fontSize = `${size}px`;
      guard += 1;
    }
  }

  requestAnimationFrame(fitNoteText);

  if ("ResizeObserver" in window) {
    const ro = new ResizeObserver(() => fitNoteText());
    ro.observe(tile);
  } else {
    window.addEventListener("resize", fitNoteText);
  }

  return tile;
}

function showImage(index) {
  const count = selectedImages.length;
  if (!count) return;
  currentIndex = (index + count) % count; // cyclic
  overlayImg.src = `${IMAGES_DIR}/${selectedImages[currentIndex]}${EXT}`;
}

// Init: detect available images, then pick & persist a stable set for this user
(async () => {
  const storageKey = getStorageKey();
  const { wideSet: initialWideSet, tallSet: initialTallSet } = getOrCreateLayoutSets(storageKey, tilesOnScreen);

  // 1) Immediate structure (no white page)
  gallery.innerHTML = "";
  for (let i = 0; i < imagesToShow; i++) {
    photoSlots.push(createPhotoSlot(i, initialWideSet, initialTallSet));
  }
  gallery.appendChild(createTextTile(tilesOnScreen - 1, initialWideSet, initialTallSet));

  // 2) If user already has a saved set, start loading it immediately (fast perceived load).
  // Debug/testing: reset the saved set via URL param, e.g. ?reset=1
  // This makes it easy to get a new set without clearing all site storage.
  const params = new URLSearchParams(location.search);
  const resetParam = (params.get("reset") || "").trim().toLowerCase();
  const shouldReset = resetParam === "1" || resetParam === "true" || resetParam === "yes";
  if (shouldReset) {
    try {
      localStorage.removeItem(storageKey);
    } catch {
      // ignore
    }
  }

  // Migrate legacy default key to "set=default" once, so existing users keep their set.
  // This only affects users who visited before "set" support was introduced.
  let savedRawEarly = safeStorageGet(storageKey);
  if (!savedRawEarly && storageKey.endsWith("set=default")) {
    const legacyKey = getLegacyStorageKey();
    const legacyVal = safeStorageGet(legacyKey);
    if (legacyVal) {
      safeStorageSet(storageKey, legacyVal);
      savedRawEarly = legacyVal;
      try {
        localStorage.removeItem(legacyKey);
      } catch {
        // ignore
      }
    }
  }
  if (savedRawEarly) {
    try {
      const parsed = JSON.parse(savedRawEarly);
      if (Array.isArray(parsed) && parsed.length) {
        selectedImages = parsed.slice(0, imagesToShow);
        selectedImages.forEach((num, index) => {
          if (photoSlots[index]) fillPhotoSlot(photoSlots[index], num, index);
        });
      }
    } catch {
      // ignore
    }
  }

  // 3) Ensure correctness: detect available images and (re)select a valid stable set.
  const available = await getAvailableImageNumbers();
  const availableSet = new Set(available);

  const savedRaw = safeStorageGet(storageKey);
  let saved = null;

  if (savedRaw) {
    try {
      const parsed = JSON.parse(savedRaw);
      if (Array.isArray(parsed)) saved = parsed;
    } catch {
      saved = null;
    }
  }

  const desiredCount = Math.min(imagesToShow, available.length);

  // Validate saved set: must be unique, correct length, and exist in the folder
  const isValidSaved =
    Array.isArray(saved) &&
    saved.length === desiredCount &&
    new Set(saved).size === saved.length &&
    saved.every((n) => availableSet.has(n));

  if (isValidSaved) {
    selectedImages = saved;
  } else {
    selectedImages = shuffle([...available]).slice(0, desiredCount);
    safeStorageSet(storageKey, JSON.stringify(selectedImages));
  }

  // 4) Fill (or refill) slots with the final chosen images.
  selectedImages.forEach((num, index) => {
    if (photoSlots[index]) fillPhotoSlot(photoSlots[index], num, index);
  });
})();

// Кнопки навигации
prevBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  showImage(currentIndex - 1);
});

nextBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  showImage(currentIndex + 1);
});

// Закрытие фото с плавным исчезновением (клик по фону)
overlay.addEventListener("click", closeOverlay);

// Не закрывать при клике по самому изображению
overlayImg.addEventListener("click", (e) => e.stopPropagation());
</script>

</body>
</html>
