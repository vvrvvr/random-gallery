<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Gallery</title>

<style>
  *, *::before, *::after {
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
  }

  body {
    margin: 0;
    padding: 20px;
    font-family: Arial, sans-serif;
    background: #fff;
    overflow: hidden; /* галерея должна помещаться в окно без скролла */
    height: 100vh;
    height: 100dvh; /* modern mobile browsers */
  }

  body.modal-open {
    overflow: hidden; /* не показывать скролл и не прокручивать страницу под оверлеем */
  }

  :root {
    --gap: 1px;
    --tile: clamp(140px, 18vw, 220px);
  }

  /* Adaptive mosaic grid (Yandex Disk-ish) */
  #gallery {
    display: grid;
    height: 100%;
    grid-template-columns: repeat(var(--cols, 5), 1fr);
    grid-template-rows: repeat(var(--rows, 4), 1fr);
    grid-auto-flow: dense;
    gap: var(--gap);
    align-content: stretch;
    justify-content: stretch;
    overflow: hidden;
  }

  .tile {
    position: relative;
    overflow: hidden;
  }

  .tile.wide {
    grid-column: span 2;
  }

  .tile.tall {
    grid-row: span 2;
  }

  /* Photo tile placeholder (shows instantly while images are loading) */
  .tile.photo {
    background: #eef1f5;
  }

  .tile.photo::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      90deg,
      rgba(255,255,255,0) 0%,
      rgba(255,255,255,0.55) 50%,
      rgba(255,255,255,0) 100%
    );
    transform: translateX(-100%);
    animation: shimmer 1.2s ease-in-out infinite;
    opacity: 0.7;
    pointer-events: none;
  }

  .tile.photo.loaded::before {
    display: none;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  /* Text tile (behaves like a tile, but isn't selectable / not part of overlay) */
  .tile.text {
    background: #f6f7f9;
    border: 1px solid rgba(0,0,0,0.08);
    padding: 16px 16px 14px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    gap: 10px;
    overflow: hidden;
    cursor: default;
  }

  .tile.text .text-title {
    margin: 0;
    font-size: 18px;
    line-height: 1.2;
    letter-spacing: 0.01em;
  }

  .tile.text .text-body {
    margin: 0;
    font-size: 14px;
    line-height: 1.45;
    color: rgba(0,0,0,0.74);
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
    white-space: pre-line; /* \n в textContent -> новая строка */
  }

  img.thumb {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 0;
    cursor: pointer;
    display: block;
    opacity: 0;
    filter: blur(18px);
    transform: scale(1.03);
    transition: opacity 220ms ease, filter 260ms ease, transform 260ms ease;
    will-change: opacity, filter, transform;
  }

  img.thumb.loaded {
    opacity: 1;
    filter: blur(0);
    transform: scale(1);
  }



  /* Overlay */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(20,20,20,0.95);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.18s ease;
    overflow: hidden;
  }

  .close-btn {
    position: fixed;
    top: 14px;
    right: 14px;
    width: 74px;
    height: 74px;
    border-radius: 999px;
    border: none;
    background: rgba(0,0,0,0.3);
    color: rgba(255,255,255,0.95);
    font-size: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    z-index: 3; /* всегда выше изображения и кнопок листания */
    transition: background 120ms ease, transform 60ms ease;
  }

  .close-btn:hover {
    background: rgba(255,255,255,0.2);
  }

  .close-btn:active {
    transform: scale(0.97);
  }

  .counter {
    position: fixed;
    left: 50%;
    bottom: 14px;
    transform: translateX(-50%);
    padding: 12px 18px;
    border-radius: 999px;
    background: rgba(0,0,0,0.3);
    color: rgba(255,255,255,0.95);
    font-size: 21px;
    line-height: 1;
    user-select: none;
    z-index: 3; /* поверх изображения */
    cursor: default;
  }

  .overlay.active {
    opacity: 1;
    visibility: visible;
  }

  /* Swipe stage */
  .stage {
    position: absolute;
    inset: 0;
    z-index: 1; /* ниже кнопок */
    touch-action: none; /* allow horizontal drag without browser gestures */
    cursor: grab;
  }

  .stage.dragging {
    cursor: grabbing;
  }

  .slide {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    will-change: transform;
    pointer-events: auto;
    background: rgba(238, 241, 245, 0.22);
    overflow: hidden;
  }

  .slide img {
    max-width: 95vw;
    max-height: 95vh;
    width: auto;
    height: auto;
    object-fit: contain;
    box-shadow: 0 8px 22px rgba(0,0,0,0.28);
    /* transform is controlled by JS for pinch-zoom + pan */
    transform-origin: center center;
    will-change: transform;
    opacity: 0;
    transition: opacity 160ms ease;
    pointer-events: auto; /* still allow starting a drag from the photo */
    user-select: none;
    -webkit-user-drag: none;
  }

  .slide img.loaded {
    opacity: 1;
  }

  /* .overlay.active .slide img transform removed: JS handles zoom */

  /* Навигационные кнопки */
  .nav-btn {
    position: fixed; /* фиксируем относительно окна */
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 2.4rem;
    font-weight: bold;
    background: rgba(0,0,0,0.3);
    border: none;
    padding: 12px 18px;
    cursor: pointer;
    user-select: none;
    border-radius: 4px;
    z-index: 2; /* выше изображения */
    transition: background 120ms ease, transform 60ms ease;
  }

  .nav-btn:hover {
    background: rgba(255,255,255,0.2);
  }

  .nav-btn:active {
    transform: translateY(-50%) scale(0.97);
  }

  #prevBtn { left: 10px; }
  #nextBtn { right: 10px; }
</style>
</head>

<body>

<div id="gallery"></div>

<div class="overlay" id="overlay">
  <button class="nav-btn" id="prevBtn">&#10094;</button>
  <button class="close-btn" id="closeBtn" aria-label="Закрыть">×</button>
  <div class="counter" id="counter"></div>
  <div class="stage" id="stage" aria-label="Просмотр фото">
    <div class="slide" data-slot="prev"><img class="overlay-photo" id="overlayPrevImg" alt="" draggable="false"></div>
    <div class="slide" data-slot="current"><img class="overlay-photo" id="overlayCurrImg" alt="" draggable="false"></div>
    <div class="slide" data-slot="next"><img class="overlay-photo" id="overlayNextImg" alt="" draggable="false"></div>
  </div>
  <button class="nav-btn" id="nextBtn">&#10095;</button>
</div>

<script>
// Global set id (controlled in this file).
// Change this value (and redeploy) to roll a new stable "set" for all users of that deployed version.
const SET_ID = "set2";

// One switch for randomness:
// - true  => on every page reload: NEW mosaic layout + NEW set of 10 images (no persistence)
// - false => stable mosaic + stable set of 10 images per browser/profile (via localStorage)
const RANDOM_EACH_RELOAD = true;

// Random salt for this page load (used when RANDOM_EACH_RELOAD=true)
const RELOAD_SALT = (() => {
  try {
    const buf = new Uint32Array(1);
    crypto.getRandomValues(buf);
    return buf[0] >>> 0;
  } catch {
    return (Math.floor(Math.random() * 4294967296) >>> 0);
  }
})();

const imagesToShow = 10;
const IMAGES_DIR = "images";
// Image format preference: try WebP first, fallback to JPG (useful while you convert gradually).
const EXT_PRIMARY = ".webp";
const EXT_FALLBACK = ".jpg";

// Performance hint (recommended for mobile):
// If your images are numbered 1..N without gaps, set this to N to skip network probing entirely.
// Set to 0 to auto-detect (fast path assumes contiguous numbering; falls back to slower probing if needed).
const IMAGES_COUNT = 58;
const PROBE_MAX = 500; // upper bound for numbered images like 1.jpg..N.jpg
const PROBE_STOP_AFTER_MISSES = 25; // stop after N consecutive misses once we've found at least one
const PROBE_TIMEOUT_MS = 1800;

const overlay = document.getElementById("overlay");
const stage = document.getElementById("stage");
const overlayPrevImg = document.getElementById("overlayPrevImg");
const overlayCurrImg = document.getElementById("overlayCurrImg");
const overlayNextImg = document.getElementById("overlayNextImg");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const closeBtn = document.getElementById("closeBtn");
const counter = document.getElementById("counter");
const gallery = document.getElementById("gallery");

let selectedImages = [];
let currentIndex = 0;
const tilesOnScreen = imagesToShow + 1; // 10 photos + 1 text tile

// Swipe / animated navigation (Telegram-like)
const SLIDE_GAP_PX = 10; // small spacing between photos during swipe
const SWIPE_THRESHOLD_RATIO = 0.5; // 50% of viewport width
const SLIDE_ANIM_MS = 500; // slower (2x) for smoother swipe
const FLICK_VELOCITY_PX_PER_MS = 1.0; // ~1000px/s: fast swipe should flip without reaching half
const FLICK_MIN_DISTANCE_PX = 25; // don't flip on tiny accidental taps

const prevSlide = overlayPrevImg.parentElement;
const currSlide = overlayCurrImg.parentElement;
const nextSlide = overlayNextImg.parentElement;

const swipe = {
  active: false,
  pointerId: null,
  startX: 0,
  dx: 0,
  animating: false,
  timer: null,
  animToken: 0,
  animDelta: 0,
  suppressClick: false,
  startAt: 0,
  lastX: 0,
  vx: 0, // px/ms (smoothed)
  lastMoveAt: 0,
};

// Pinch-zoom + pan (Telegram-like)
const zoomState = {
  mode: "none", // "none" | "swipe" | "pan" | "pinch"
  pointers: new Map(), // pointerId -> { x, y }
  zoom: 1,
  panX: 0,
  panY: 0,
  baseW: 0,
  baseH: 0,
  lastX: 0,
  lastY: 0,
  pinchStartDist: 0,
  pinchStartZoom: 1,
  pinchLastMidX: 0,
  pinchLastMidY: 0,
  maxZoom: 3.25,
  // double-tap
  lastTapAt: 0,
  lastTapX: 0,
  lastTapY: 0,
  doubleTapZoom: 2.2,
};

function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function applyZoom() {
  overlayCurrImg.style.transition = "none";
  overlayCurrImg.style.transform = `translate3d(${zoomState.panX}px, ${zoomState.panY}px, 0) scale(${zoomState.zoom})`;
}

function updateZoomBaseSize() {
  // Measure at zoom=1/pan=0 only
  const prevZoom = zoomState.zoom;
  const prevPanX = zoomState.panX;
  const prevPanY = zoomState.panY;
  zoomState.zoom = 1;
  zoomState.panX = 0;
  zoomState.panY = 0;
  applyZoom();

  const r = overlayCurrImg.getBoundingClientRect();
  zoomState.baseW = r.width || zoomState.baseW || 0;
  zoomState.baseH = r.height || zoomState.baseH || 0;

  zoomState.zoom = prevZoom;
  zoomState.panX = prevPanX;
  zoomState.panY = prevPanY;
  applyZoom();
}

function clampPan() {
  const stageRect = stage.getBoundingClientRect();
  const sw = stageRect.width || stageWidth();
  const sh = stageRect.height || window.innerHeight;
  const bw = zoomState.baseW || overlayCurrImg.getBoundingClientRect().width || sw;
  const bh = zoomState.baseH || overlayCurrImg.getBoundingClientRect().height || sh;

  const w = bw * zoomState.zoom;
  const h = bh * zoomState.zoom;
  const maxX = Math.max(0, (w - sw) / 2);
  const maxY = Math.max(0, (h - sh) / 2);

  zoomState.panX = clamp(zoomState.panX, -maxX, maxX);
  zoomState.panY = clamp(zoomState.panY, -maxY, maxY);
}

function getPanBounds() {
  const stageRect = stage.getBoundingClientRect();
  const sw = stageRect.width || stageWidth();
  const sh = stageRect.height || window.innerHeight;
  const bw = zoomState.baseW || overlayCurrImg.getBoundingClientRect().width || sw;
  const bh = zoomState.baseH || overlayCurrImg.getBoundingClientRect().height || sh;

  const w = bw * zoomState.zoom;
  const h = bh * zoomState.zoom;
  return {
    maxX: Math.max(0, (w - sw) / 2),
    maxY: Math.max(0, (h - sh) / 2),
    sw,
    sh,
  };
}

function withRubberBand(value, maxAbs, k = 0.35) {
  const a = Math.abs(value);
  if (a <= maxAbs) return value;
  const s = value < 0 ? -1 : 1;
  return s * (maxAbs + (a - maxAbs) * k);
}

function applyPanWithResistance() {
  const { maxX, maxY } = getPanBounds();
  zoomState.panX = withRubberBand(zoomState.panX, maxX);
  zoomState.panY = withRubberBand(zoomState.panY, maxY);
  applyZoom();
}

function snapPanBack() {
  const { maxX, maxY } = getPanBounds();
  const targetX = clamp(zoomState.panX, -maxX, maxX);
  const targetY = clamp(zoomState.panY, -maxY, maxY);
  zoomState.panX = targetX;
  zoomState.panY = targetY;
  overlayCurrImg.style.transition = "transform 180ms cubic-bezier(0.2, 0.9, 0.2, 1)";
  overlayCurrImg.style.transform = `translate3d(${zoomState.panX}px, ${zoomState.panY}px, 0) scale(${zoomState.zoom})`;
  window.setTimeout(() => {
    overlayCurrImg.style.transition = "none";
  }, 220);
}

function resetZoom() {
  zoomState.zoom = 1;
  zoomState.panX = 0;
  zoomState.panY = 0;
  clampPan();
  applyZoom();
}

function toggleZoomAt(clientX, clientY) {
  const sr = stage.getBoundingClientRect();
  const tapX = clientX - sr.left;
  const tapY = clientY - sr.top;
  const cx = sr.width / 2;
  const cy = sr.height / 2;

  if (zoomState.zoom > 1.02) {
    zoomState.zoom = 1;
    zoomState.panX = 0;
    zoomState.panY = 0;
  } else {
    updateZoomBaseSize();
    const z = clamp(zoomState.doubleTapZoom, 1, zoomState.maxZoom);
    // Keep the tapped point in place while zooming (Telegram-like)
    zoomState.zoom = z;
    zoomState.panX = (tapX - cx) * (1 - z);
    zoomState.panY = (tapY - cy) * (1 - z);
    clampPan();
  }

  overlayCurrImg.style.transition = "transform 200ms cubic-bezier(0.2, 0.9, 0.2, 1)";
  overlayCurrImg.style.transform = `translate3d(${zoomState.panX}px, ${zoomState.panY}px, 0) scale(${zoomState.zoom})`;
  window.setTimeout(() => {
    overlayCurrImg.style.transition = "none";
  }, 240);
}

function addZoomPointer(e) {
  zoomState.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
}

function updateZoomPointer(e) {
  const p = zoomState.pointers.get(e.pointerId);
  if (!p) return;
  p.x = e.clientX;
  p.y = e.clientY;
}

function removeZoomPointer(e) {
  zoomState.pointers.delete(e.pointerId);
}

function getTwoZoomPointers() {
  const it = zoomState.pointers.values();
  const p1 = it.next().value;
  const p2 = it.next().value;
  if (!p1 || !p2) return null;
  return [p1, p2];
}

function dist2(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function getCurrentDxPx() {
  const t = window.getComputedStyle(currSlide).transform;
  if (!t || t === "none") return 0;
  const m2 = t.match(/^matrix\((.+)\)$/);
  if (m2) {
    const parts = m2[1].split(",").map((v) => parseFloat(v.trim()));
    return Number.isFinite(parts[4]) ? parts[4] : 0;
  }
  const m3 = t.match(/^matrix3d\((.+)\)$/);
  if (m3) {
    const parts = m3[1].split(",").map((v) => parseFloat(v.trim()));
    return Number.isFinite(parts[12]) ? parts[12] : 0;
  }
  return 0;
}

function cancelSwipeAnimation() {
  if (!swipe.animating) return;
  swipe.animToken += 1; // invalidate pending timers
  if (swipe.timer) {
    window.clearTimeout(swipe.timer);
    swipe.timer = null;
  }
  swipe.animating = false;

  // If user interrupts an in-flight flip, commit it immediately.
  if (swipe.animDelta) {
    currentIndex = wrapIndex(currentIndex + swipe.animDelta);
    updateCounter();
    updateOverlaySlides();
    resetZoom();
    requestAnimationFrame(updateZoomBaseSize);
    prefetchAround();
  }

  swipe.animDelta = 0;
  swipe.dx = 0;
  swipe.vx = 0;
  setSlideTransform(0, { animate: false });
}

function stageWidth() {
  const rect = stage.getBoundingClientRect();
  return Math.max(1, rect.width || window.innerWidth || 1);
}

function slideDistancePx() {
  return stageWidth() + SLIDE_GAP_PX;
}

function wrapIndex(i) {
  const count = selectedImages.length;
  if (!count) return 0;
  return (i + count) % count;
}

function setSlideTransform(dxPx, { animate } = { animate: false }) {
  const dist = slideDistancePx();
  const easing = "cubic-bezier(0.2, 0.9, 0.2, 1)";
  const transition = animate ? `transform ${SLIDE_ANIM_MS}ms ${easing}` : "none";

  prevSlide.style.transition = transition;
  currSlide.style.transition = transition;
  nextSlide.style.transition = transition;

  prevSlide.style.transform = `translateX(${-dist + dxPx}px)`;
  currSlide.style.transform = `translateX(${dxPx}px)`;
  nextSlide.style.transform = `translateX(${dist + dxPx}px)`;
}

function updateOverlaySlides() {
  const count = selectedImages.length;
  if (!count) return;

  const iPrev = wrapIndex(currentIndex - 1);
  const iCurr = wrapIndex(currentIndex);
  const iNext = wrapIndex(currentIndex + 1);

  overlayPrevImg.classList.remove("loaded");
  setImgSrcWithFallback(overlayPrevImg, selectedImages[iPrev], () => {
    overlayPrevImg.removeAttribute("src");
    delete overlayPrevImg.dataset.num;
    delete overlayPrevImg.dataset.ext;
  }, () => {
    overlayPrevImg.classList.add("loaded");
  });

  overlayCurrImg.classList.remove("loaded");
  setImgSrcWithFallback(overlayCurrImg, selectedImages[iCurr], () => {
    overlayCurrImg.removeAttribute("src");
    delete overlayCurrImg.dataset.num;
    delete overlayCurrImg.dataset.ext;
  }, () => {
    overlayCurrImg.classList.add("loaded");
  });

  overlayNextImg.classList.remove("loaded");
  setImgSrcWithFallback(overlayNextImg, selectedImages[iNext], () => {
    overlayNextImg.removeAttribute("src");
    delete overlayNextImg.dataset.num;
    delete overlayNextImg.dataset.ext;
  }, () => {
    overlayNextImg.classList.add("loaded");
  });

  // Reset transforms for non-current slides; current is controlled by zoomState
  overlayPrevImg.style.transform = "translate3d(0,0,0) scale(1)";
  overlayNextImg.style.transform = "translate3d(0,0,0) scale(1)";
}

function animateBy(delta) {
  const count = selectedImages.length;
  if (!count || count === 1) return;
  if (swipe.animating) return;

  const dist = slideDistancePx();
  swipe.animating = true;
  swipe.animToken += 1;
  const token = swipe.animToken;
  swipe.animDelta = delta;

  // delta: +1 => next (swipe left), -1 => prev (swipe right)
  const targetDx = -delta * dist;
  setSlideTransform(targetDx, { animate: true });

  swipe.timer = window.setTimeout(() => {
    if (token !== swipe.animToken) return;
    currentIndex = wrapIndex(currentIndex + delta);
    updateCounter();
    updateOverlaySlides();
    resetZoom();
    requestAnimationFrame(updateZoomBaseSize);
    prefetchAround();
    // snap back to the centered state without animation
    setSlideTransform(0, { animate: false });
    swipe.dx = 0;
    swipe.animDelta = 0;
    swipe.animating = false;
    swipe.timer = null;
  }, SLIDE_ANIM_MS + 20);
}

function lockPageScroll() {
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.body.classList.add("modal-open");
  if (scrollbarWidth > 0) {
    document.body.style.paddingRight = `${scrollbarWidth}px`;
  }
}

function unlockPageScroll() {
  document.body.classList.remove("modal-open");
  document.body.style.paddingRight = "";
}

function closeOverlay() {
  overlay.classList.remove("active");
  // Reset swipe state so next open starts centered
  cancelSwipeAnimation();
  zoomState.pointers.clear();
  zoomState.mode = "none";
  zoomState.lastTapAt = 0;
  resetZoom();
  swipe.active = false;
  swipe.pointerId = null;
  swipe.dx = 0;
  swipe.suppressClick = false;
  swipe.animating = false;
  stage.classList.remove("dragging");
  setSlideTransform(0, { animate: false });
  setTimeout(() => {
    if (!overlay.classList.contains("active")) {
      overlay.style.visibility = "hidden";
      unlockPageScroll();
    }
  }, 180); // совпадает с transition
}

function updateCounter() {
  const count = selectedImages.length;
  if (!count) {
    counter.textContent = "";
    return;
  }
  counter.textContent = `${currentIndex + 1} / ${count}`;
}

// Render the grid structure immediately (placeholders), then fill images progressively.
const photoSlots = [];
let textTileEl = null;
let storageKey = "";

function createPhotoSlot(index) {
  const tile = document.createElement("div");
  tile.className = "tile photo";

  const img = document.createElement("img");
  img.className = "thumb";
  img.alt = "";
  img.loading = "lazy";
  img.decoding = "async";

  tile.appendChild(img);
  gallery.appendChild(tile);
  return { tile, img };
}

function shuffle(arr, rnd = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rnd() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function fnv1a32(str) {
  // 32-bit FNV-1a hash
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}

function mulberry32(seed) {
  // Deterministic PRNG in [0,1)
  let a = seed >>> 0;
  return function () {
    a = (a + 0x6d2b79f5) >>> 0;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function getUserSeed() {
  // One seed per browser/profile (per origin). Used to keep layout stable on refresh,
  // while still being different across different users/browsers.
  const KEY = "myImages:userSeed";
  const existing = safeStorageGet(KEY);
  if (existing) return existing;

  let seed = "";
  try {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    seed = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
  } catch {
    seed = String(Date.now()) + ":" + String(Math.random());
  }

  safeStorageSet(KEY, seed);
  return seed;
}

function getStorageKey() {
  // localStorage is per-origin; add pathname so different pages don't conflict
  const path = (location.pathname || "/").replace(/\/$/, "");

  // Optional debug/testing override via URL, e.g. ?set=2
  // Different "set" values produce independent saved selections.
  const params = new URLSearchParams(location.search);
  const urlSet = (params.get("set") || "").trim();
  const set = (urlSet || SET_ID || "default").trim();

  return `myImages:${path || "/"}:set=${set}`;
}

function getLegacyStorageKey() {
  // Legacy key (before "set" support existed)
  const path = (location.pathname || "/").replace(/\/$/, "");
  return `myImages:${path || "/"}`;
}

function safeStorageGet(key) {
  try {
    return localStorage.getItem(key);
  } catch {
    return null;
  }
}

function safeStorageSet(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch {
    // ignore (private mode / disabled storage)
  }
}

async function probeImage(url) {
  // Fast existence check (works well on GitHub Pages).
  try {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), PROBE_TIMEOUT_MS);
    let res = await fetch(url, { method: "HEAD", signal: ctrl.signal, cache: "force-cache" });
    clearTimeout(t);

    // Some hosts may not support HEAD
    if (res.status === 405) {
      res = await fetch(url, { method: "GET", cache: "force-cache" });
    }

    return res.ok;
  } catch {
    // Fallback: image probe (older browsers / odd fetch failures)
    return await new Promise((resolve) => {
      const img = new Image();
      const t = setTimeout(() => {
        img.onload = null;
        img.onerror = null;
        resolve(false);
      }, PROBE_TIMEOUT_MS);

      img.onload = () => {
        clearTimeout(t);
        resolve(true);
      };
      img.onerror = () => {
        clearTimeout(t);
        resolve(false);
      };

      img.src = url;
    });
  }
}

function imageUrl(num, ext) {
  return `${IMAGES_DIR}/${num}${ext}`;
}

function setImgSrcWithFallback(imgEl, num, onMissing, onLoaded) {
  const desiredNum = String(num);
  const primaryUrl = imageUrl(num, EXT_PRIMARY);
  const fallbackUrl = imageUrl(num, EXT_FALLBACK);

  imgEl.dataset.num = desiredNum;
  imgEl.dataset.ext = "primary";
  imgEl.src = primaryUrl;

  const prevOnload = imgEl.onload;
  imgEl.onload = (...args) => {
    if (typeof prevOnload === "function") prevOnload(...args);
    if (typeof onLoaded === "function") onLoaded();
  };

  const prevOnerror = imgEl.onerror;
  imgEl.onerror = () => {
    if (imgEl.dataset.ext === "primary") {
      imgEl.dataset.ext = "fallback";
      imgEl.src = fallbackUrl;
      return;
    }
    // missing/broken
    if (typeof onMissing === "function") onMissing();
    if (typeof prevOnerror === "function") prevOnerror();
  };
}

// Prefetch a few images ahead/behind so fast swipes don't hit blank frames on slow mobile networks.
const prefetchCache = new Set();
function prefetchImage(num) {
  const key = String(num);
  if (prefetchCache.has(key)) return;
  prefetchCache.add(key);

  const img = new Image();
  img.decoding = "async";
  img.onload = () => {};
  img.onerror = () => {
    const img2 = new Image();
    img2.decoding = "async";
    img2.src = imageUrl(num, EXT_FALLBACK);
  };
  img.src = imageUrl(num, EXT_PRIMARY);
}

function prefetchAround() {
  const count = selectedImages.length;
  if (!count) return;
  const radius = 3;
  for (let d = 1; d <= radius; d++) {
    const n1 = selectedImages[wrapIndex(currentIndex + d)];
    const n2 = selectedImages[wrapIndex(currentIndex - d)];
    if (n1) prefetchImage(n1);
    if (n2) prefetchImage(n2);
  }
}

async function probeImageNumber(num) {
  // Prefer WebP but accept JPG during migration.
  const primaryOk = await probeImage(imageUrl(num, EXT_PRIMARY));
  if (primaryOk) return true;
  return await probeImage(imageUrl(num, EXT_FALLBACK));
}

async function getAvailableImageNumbersSlow() {
  const found = [];
  let misses = 0;
  let foundAny = false;

  for (let i = 1; i <= PROBE_MAX; i++) {
    const ok = await probeImageNumber(i);
    if (ok) {
      found.push(i);
      foundAny = true;
      misses = 0;
    } else if (foundAny) {
      misses += 1;
      if (misses >= PROBE_STOP_AFTER_MISSES) break;
    }
  }

  return found;
}

async function getAvailableImageNumbers() {
  // Fast path:
  // - if IMAGES_COUNT is provided, don't probe at all
  // - otherwise, assume images are contiguous 1..N and find N with ~O(log N) probes
  // If assumptions fail, fallback to the slow full scan.
  if (Number.isInteger(IMAGES_COUNT) && IMAGES_COUNT > 0) {
    return Array.from({ length: Math.min(IMAGES_COUNT, PROBE_MAX) }, (_, i) => i + 1);
  }

  try {
    const firstOk = await probeImageNumber(1);
    if (!firstOk) return [];

    let lo = 1;
    let hi = 2;

    while (hi <= PROBE_MAX) {
      const ok = await probeImageNumber(hi);
      if (!ok) break;
      lo = hi;
      hi *= 2;
    }

    if (hi > PROBE_MAX) {
      // Might still be < PROBE_MAX; verify PROBE_MAX itself
      const okMax = await probeImageNumber(PROBE_MAX);
      if (okMax) {
        return Array.from({ length: PROBE_MAX }, (_, i) => i + 1);
      }
      hi = PROBE_MAX;
    }

    // Binary search last existing in [lo, hi)
    let left = lo;
    let right = Math.min(hi, PROBE_MAX + 1); // exclusive
    while (left + 1 < right) {
      const mid = left + Math.floor((right - left) / 2);
      const ok = await probeImageNumber(mid);
      if (ok) left = mid;
      else right = mid;
    }

    const max = left;
    if (max >= 1) {
      return Array.from({ length: max }, (_, i) => i + 1);
    }

    return [];
  } catch {
    return await getAvailableImageNumbersSlow();
  }
}

function solveMosaic(cols, rows, tileCount, rnd) {
  const totalCells = cols * rows;
  const occ = new Array(totalCells).fill(false);
  const placements = [];
  const shapes = [
    { w: 2, h: 2 },
    { w: 2, h: 1 },
    { w: 1, h: 2 },
    { w: 1, h: 1 },
  ];

  function idx(x, y) {
    return y * cols + x;
  }

  function findFirstEmpty() {
    for (let i = 0; i < totalCells; i++) {
      if (!occ[i]) return { x: i % cols, y: Math.floor(i / cols) };
    }
    return null;
  }

  function canPlace(x, y, w, h) {
    if (x + w > cols || y + h > rows) return false;
    for (let yy = y; yy < y + h; yy++) {
      for (let xx = x; xx < x + w; xx++) {
        if (occ[idx(xx, yy)]) return false;
      }
    }
    return true;
  }

  function setOcc(x, y, w, h, v) {
    for (let yy = y; yy < y + h; yy++) {
      for (let xx = x; xx < x + w; xx++) {
        occ[idx(xx, yy)] = v;
      }
    }
  }

  function backtrack(usedTiles, filledCells) {
    if (usedTiles === tileCount) return filledCells === totalCells;

    const remainingTiles = tileCount - usedTiles;
    const remainingCells = totalCells - filledCells;
    if (remainingCells < remainingTiles) return false; // need at least 1 cell per tile
    if (remainingCells > remainingTiles * 4) return false; // max 2x2 per tile

    const cell = findFirstEmpty();
    if (!cell) return false;

    // Deterministic per-user variety: shuffle trial order
    const trial = shapes.slice();
    shuffle(trial, rnd);

    for (const s of trial) {
      const area = s.w * s.h;
      // Extra quick feasibility check after placing this shape
      const nextRemainingCells = remainingCells - area;
      const nextRemainingTiles = remainingTiles - 1;
      if (nextRemainingCells < nextRemainingTiles) continue;
      if (nextRemainingCells > nextRemainingTiles * 4) continue;

      if (!canPlace(cell.x, cell.y, s.w, s.h)) continue;
      setOcc(cell.x, cell.y, s.w, s.h, true);
      placements.push({ x: cell.x, y: cell.y, w: s.w, h: s.h });

      if (backtrack(usedTiles + 1, filledCells + area)) return true;

      placements.pop();
      setOcc(cell.x, cell.y, s.w, s.h, false);
    }

    return false;
  }

  return backtrack(0, 0) ? placements : null;
}

function pickMosaicLayout(containerW, containerH, tileCount) {
  const target = containerW / Math.max(1, containerH);
  const candidates = [
    { cols: 3, rows: 4 },
    { cols: 3, rows: 5 },
    { cols: 4, rows: 4 },
    { cols: 4, rows: 5 },
    { cols: 5, rows: 4 },
    { cols: 5, rows: 5 },
    { cols: 6, rows: 4 },
    { cols: 3, rows: 6 },
    { cols: 2, rows: 6 },
  ];

  function score(c) {
    const area = c.cols * c.rows;
    if (area < tileCount) return Infinity;

    const ratio = c.cols / c.rows;
    const aspectDiff = Math.abs(ratio - target);
    const cellMin = Math.min(containerW / c.cols, containerH / c.rows);

    // Prefer not-too-tiny cells
    const tinyPenalty = cellMin < 70 ? (70 - cellMin) / 10 : 0;

    // Prefer moderate area (enough for mosaic, but not overly fragmented)
    const areaTarget = tileCount * 1.8;
    const areaPenalty = Math.abs(area - areaTarget) / tileCount;

    return aspectDiff * 2 + areaPenalty + tinyPenalty;
  }

  return candidates
    .map((c) => ({ ...c, s: score(c) }))
    .sort((a, b) => a.s - b.s)
    .map(({ cols, rows }) => ({ cols, rows }));
}

function applyMosaicLayout() {
  const tiles = [...photoSlots.map((s) => s.tile), textTileEl].filter(Boolean);
  if (!tiles.length || !storageKey) return;

  const rect = gallery.getBoundingClientRect();
  const w = Math.max(1, rect.width);
  const h = Math.max(1, rect.height);

  const candidates = pickMosaicLayout(w, h, tiles.length);
  const seedBase = RANDOM_EACH_RELOAD ? `reload:${RELOAD_SALT}` : `user:${getUserSeed()}`;

  for (const c of candidates) {
    const seed = fnv1a32(`${seedBase}|${storageKey}|mosaic|${c.cols}x${c.rows}`);
    const rnd = mulberry32(seed);
    const placements = solveMosaic(c.cols, c.rows, tiles.length, rnd);
    if (!placements) continue;

    gallery.style.setProperty("--cols", String(c.cols));
    gallery.style.setProperty("--rows", String(c.rows));

    tiles.forEach((tile, i) => {
      const p = placements[i];
      tile.style.gridColumn = `${p.x + 1} / span ${p.w}`;
      tile.style.gridRow = `${p.y + 1} / span ${p.h}`;
    });

    return;
  }
}

function fillPhotoSlot(slot, num, index) {
  const { tile, img } = slot;
  const desiredNum = String(num);

  // If this slot already shows the same image, don't reassign src / restart transitions.
  // This prevents the "loads twice" effect (early load from localStorage + later validation pass).
  if (img.dataset.num === desiredNum) {
    // Ensure click is bound to this slot index.
    img.onclick = () => {
      showImage(index);
      overlay.classList.add("active");
      overlay.style.visibility = "visible";
      lockPageScroll();
    };
    return;
  }

  img.classList.remove("loaded");
  tile.classList.remove("loaded");

  img.onload = () => {
    img.classList.add("loaded");
    tile.classList.add("loaded");
  };

  setImgSrcWithFallback(img, num, () => {
    // Keep placeholder if missing/broken.
    img.removeAttribute("src");
    img.classList.remove("loaded");
    tile.classList.remove("loaded");
    delete img.dataset.num;
    delete img.dataset.ext;
  });

  // Attach click only for real photos
  img.onclick = () => {
    showImage(index);
    overlay.classList.add("active");
    overlay.style.visibility = "visible";
    lockPageScroll();
  };
}

function createTextTile() {
  const tile = document.createElement("div");
  tile.className = "tile text";

  const h = document.createElement("h3");
  h.className = "text-title";
  h.textContent = "vladimir svistunov: вечная битва";

  const p = document.createElement("p");
  p.className = "text-body";
  p.textContent =
    "Бесконечный цикл смертей и перерождений в предопределенной битве богов.\n(Из массива фотографий каждый раз случайно формируется выборка из десяти работ)";

  tile.appendChild(h);
  tile.appendChild(p);

  // Keep title size stable, but scale the note text down when the tile is smaller.
  const NOTE_BASE_PX = 14;
  const NOTE_MIN_PX = 8;
  const NOTE_STEP_PX = 0.5;
  const TITLE_BASE_PX = 18; // matches CSS default
  const TITLE_MIN_PX = 14;

  function fitNoteText() {
    // Reset any previous clamping / inline tweaks
    p.style.display = "";
    p.style.webkitLineClamp = "";
    p.style.webkitBoxOrient = "";
    p.style.lineHeight = "";

    tile.style.padding = "";
    tile.style.gap = "";
    h.style.fontSize = "";

    let bodySize = NOTE_BASE_PX;
    let lineHeight = 1.45;
    let titleSize = TITLE_BASE_PX;

    let padX = 16;
    let padTop = 16;
    let padBottom = 14;
    let gap = 10;

    const apply = () => {
      p.style.fontSize = `${bodySize}px`;
      p.style.lineHeight = String(lineHeight);
      h.style.fontSize = `${titleSize}px`;
      tile.style.gap = `${gap}px`;
      tile.style.padding = `${padTop}px ${padX}px ${padBottom}px`;
    };

    apply();

    let guard = 0;
    while (tile.scrollHeight > tile.clientHeight && guard < 90) {
      if (bodySize > NOTE_MIN_PX) {
        bodySize = Math.max(NOTE_MIN_PX, bodySize - NOTE_STEP_PX);
      } else if (lineHeight > 1.15) {
        lineHeight = Math.max(1.15, +(lineHeight - 0.05).toFixed(2));
      } else if (titleSize > TITLE_MIN_PX) {
        titleSize = Math.max(TITLE_MIN_PX, +(titleSize - 0.5).toFixed(1));
      } else if (gap > 6) {
        gap -= 1;
      } else if (padX > 10 || padTop > 10 || padBottom > 9) {
        padX = Math.max(10, padX - 1);
        padTop = Math.max(10, padTop - 1);
        padBottom = Math.max(9, padBottom - 1);
      } else {
        break;
      }

      apply();
      guard += 1;
    }

    // Absolute guarantee: clamp text so it never overflows the tile.
    // (This only triggers in extremely small tiles.)
    if (tile.scrollHeight > tile.clientHeight) {
      const computed = window.getComputedStyle(p);
      const fs = parseFloat(computed.fontSize) || NOTE_MIN_PX;
      const lh = parseFloat(computed.lineHeight) || fs * 1.2;
      const maxLines = Math.max(1, Math.floor(p.clientHeight / lh));

      p.style.display = "-webkit-box";
      p.style.webkitBoxOrient = "vertical";
      p.style.webkitLineClamp = String(maxLines);
      // `overflow: hidden` already in CSS
    }
  }

  requestAnimationFrame(fitNoteText);

  if ("ResizeObserver" in window) {
    const ro = new ResizeObserver(() => fitNoteText());
    ro.observe(tile);
  } else {
    window.addEventListener("resize", fitNoteText);
  }

  return tile;
}

function showImage(index) {
  const count = selectedImages.length;
  if (!count) return;
  if (swipe.animating) cancelSwipeAnimation();
  currentIndex = (index + count) % count; // cyclic
  updateCounter();
  updateOverlaySlides();
  resetZoom();
  requestAnimationFrame(updateZoomBaseSize);
  prefetchAround();
  setSlideTransform(0, { animate: false });
  swipe.dx = 0;
}

// Init: detect available images, then pick & persist a stable set for this user
(async () => {
  storageKey = getStorageKey();

  // 1) Immediate structure (no white page)
  gallery.innerHTML = "";
  photoSlots.length = 0;
  for (let i = 0; i < imagesToShow; i++) {
    photoSlots.push(createPhotoSlot(i));
  }
  textTileEl = createTextTile();
  gallery.appendChild(textTileEl);

  // Apply deterministic full-screen mosaic layout (no scroll, stable on refresh)
  requestAnimationFrame(applyMosaicLayout);
  if ("ResizeObserver" in window) {
    const ro = new ResizeObserver(() => requestAnimationFrame(applyMosaicLayout));
    ro.observe(gallery);
  } else {
    window.addEventListener("resize", () => requestAnimationFrame(applyMosaicLayout));
  }

  if (!RANDOM_EACH_RELOAD) {
    // 2) If user already has a saved set, start loading it immediately (fast perceived load).
    // Debug/testing: reset the saved set via URL param, e.g. ?reset=1
    // This makes it easy to get a new set without clearing all site storage.
    const params = new URLSearchParams(location.search);
    const resetParam = (params.get("reset") || "").trim().toLowerCase();
    const shouldReset = resetParam === "1" || resetParam === "true" || resetParam === "yes";
    if (shouldReset) {
      try {
        localStorage.removeItem(storageKey);
      } catch {
        // ignore
      }
    }

    // Migrate legacy default key to "set=default" once, so existing users keep their set.
    // This only affects users who visited before "set" support was introduced.
    let savedRawEarly = safeStorageGet(storageKey);
    if (!savedRawEarly && storageKey.endsWith("set=default")) {
      const legacyKey = getLegacyStorageKey();
      const legacyVal = safeStorageGet(legacyKey);
      if (legacyVal) {
        safeStorageSet(storageKey, legacyVal);
        savedRawEarly = legacyVal;
        try {
          localStorage.removeItem(legacyKey);
        } catch {
          // ignore
        }
      }
    }
    if (savedRawEarly) {
      try {
        const parsed = JSON.parse(savedRawEarly);
        if (Array.isArray(parsed) && parsed.length) {
          selectedImages = parsed.slice(0, imagesToShow);
          selectedImages.forEach((num, index) => {
            if (photoSlots[index]) fillPhotoSlot(photoSlots[index], num, index);
          });
        }
      } catch {
        // ignore
      }
    }
  }

  // 3) Ensure correctness: detect available images and (re)select a valid stable set.
  const available = await getAvailableImageNumbers();
  const availableSet = new Set(available);

  const desiredCount = Math.min(imagesToShow, available.length);

  if (RANDOM_EACH_RELOAD) {
    const rnd = mulberry32(fnv1a32(`reload:${RELOAD_SALT}|${storageKey}|images`));
    selectedImages = shuffle([...available], rnd).slice(0, desiredCount);
  } else {
    const savedRaw = safeStorageGet(storageKey);
    let saved = null;

    if (savedRaw) {
      try {
        const parsed = JSON.parse(savedRaw);
        if (Array.isArray(parsed)) saved = parsed;
      } catch {
        saved = null;
      }
    }

    // Validate saved set: must be unique, correct length, and exist in the folder
    const isValidSaved =
      Array.isArray(saved) &&
      saved.length === desiredCount &&
      new Set(saved).size === saved.length &&
      saved.every((n) => availableSet.has(n));

    if (isValidSaved) {
      selectedImages = saved;
    } else {
      selectedImages = shuffle([...available]).slice(0, desiredCount);
      safeStorageSet(storageKey, JSON.stringify(selectedImages));
    }
  }

  // 4) Fill (or refill) slots with the final chosen images.
  selectedImages.forEach((num, index) => {
    if (photoSlots[index]) fillPhotoSlot(photoSlots[index], num, index);
  });
})();

// Кнопки навигации
prevBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  showImage(currentIndex - 1);
});

nextBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  showImage(currentIndex + 1);
});

// Swipe + pinch-zoom + close on background tap (Telegram-like)
stage.addEventListener("pointerdown", (e) => {
  if (!overlay.classList.contains("active")) return;
  if (swipe.animating) cancelSwipeAnimation();

  addZoomPointer(e);

  try {
    stage.setPointerCapture(e.pointerId);
  } catch {
    // ignore
  }

  swipe.suppressClick = false;
  stage.classList.add("dragging");

  // Two pointers => pinch zoom
  if (zoomState.pointers.size >= 2) {
    zoomState.mode = "pinch";
    swipe.active = false;
    swipe.pointerId = null;
    swipe.dx = 0;
    setSlideTransform(0, { animate: false });

    const pts = getTwoZoomPointers();
    if (pts) {
      const [p1, p2] = pts;
      zoomState.pinchStartDist = Math.max(1, dist2(p1, p2));
      zoomState.pinchStartZoom = zoomState.zoom;
      const sr = stage.getBoundingClientRect();
      zoomState.pinchLastMidX = ((p1.x + p2.x) / 2) - sr.left;
      zoomState.pinchLastMidY = ((p1.y + p2.y) / 2) - sr.top;
    }

    updateZoomBaseSize();
    clampPan();
    applyZoom();
    e.preventDefault();
    return;
  }

  // One pointer: if zoomed-in => pan, else => swipe
  if (zoomState.zoom > 1.01) {
    zoomState.mode = "pan";
    zoomState.lastX = e.clientX;
    zoomState.lastY = e.clientY;
    updateZoomBaseSize();
    clampPan();
    applyZoom();
    e.preventDefault();
    return;
  }

  zoomState.mode = "swipe";
  swipe.active = true;
  swipe.pointerId = e.pointerId;
  swipe.startX = e.clientX - (swipe.dx || 0);
  swipe.startAt = performance.now();
  swipe.lastMoveAt = swipe.startAt;
  swipe.lastX = e.clientX;
  swipe.vx = 0;
  setSlideTransform(swipe.dx || 0, { animate: false });

  e.preventDefault();
}, { capture: true });

// Prevent native "drag image" behavior on desktop browsers
stage.addEventListener("dragstart", (e) => e.preventDefault(), { capture: true });
overlayPrevImg.addEventListener("dragstart", (e) => e.preventDefault());
overlayCurrImg.addEventListener("dragstart", (e) => e.preventDefault());
overlayNextImg.addEventListener("dragstart", (e) => e.preventDefault());

stage.addEventListener("pointermove", (e) => {
  if (!overlay.classList.contains("active")) return;
  if (!zoomState.pointers.has(e.pointerId)) return;

  updateZoomPointer(e);

  if (zoomState.mode === "pinch") {
    const pts = getTwoZoomPointers();
    if (!pts) return;
    const [p1, p2] = pts;
    const sr = stage.getBoundingClientRect();
    const midX = ((p1.x + p2.x) / 2) - sr.left;
    const midY = ((p1.y + p2.y) / 2) - sr.top;
    const oldZoom = zoomState.zoom;

    const dist = Math.max(1, dist2(p1, p2));
    const nextZoom = clamp(
      zoomState.pinchStartZoom * (dist / Math.max(1, zoomState.pinchStartDist)),
      1,
      zoomState.maxZoom
    );

    // Move with fingers + compensate scaling around midpoint
    zoomState.panX += (midX - zoomState.pinchLastMidX);
    zoomState.panY += (midY - zoomState.pinchLastMidY);
    const cx = sr.width / 2;
    const cy = sr.height / 2;
    if (oldZoom > 0) {
      zoomState.panX += (midX - cx) * (1 - nextZoom / oldZoom);
      zoomState.panY += (midY - cy) * (1 - nextZoom / oldZoom);
    }

    zoomState.zoom = nextZoom;
    zoomState.pinchLastMidX = midX;
    zoomState.pinchLastMidY = midY;

    applyPanWithResistance();
    swipe.suppressClick = true;
    e.preventDefault();
    return;
  }

  if (zoomState.mode === "pan") {
    const dx = e.clientX - zoomState.lastX;
    const dy = e.clientY - zoomState.lastY;
    zoomState.lastX = e.clientX;
    zoomState.lastY = e.clientY;
    zoomState.panX += dx;
    zoomState.panY += dy;
    applyPanWithResistance();
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) swipe.suppressClick = true;
    e.preventDefault();
    return;
  }

  if (zoomState.mode === "swipe") {
    if (!swipe.active) return;
    if (swipe.pointerId !== e.pointerId) return;

    const now = performance.now();
    const dx = e.clientX - swipe.startX;
    swipe.dx = dx;
    const dt = Math.max(1, now - swipe.lastMoveAt);
    const step = e.clientX - swipe.lastX;
    const instVx = step / dt; // px/ms
    swipe.vx = swipe.vx * 0.8 + instVx * 0.2;
    swipe.lastMoveAt = now;
    swipe.lastX = e.clientX;

    if (Math.abs(dx) > 2) swipe.suppressClick = true;
    setSlideTransform(dx, { animate: false });

    e.preventDefault();
  }
}, { capture: true });

function finishSwipe() {
  if (!swipe.active) return;

  swipe.active = false;
  swipe.pointerId = null;
  const dx = swipe.dx;
  const w = stageWidth();
  const threshold = w * SWIPE_THRESHOLD_RATIO;

  stage.classList.remove("dragging");

  let delta = 0;
  if (dx <= -threshold) delta = 1;
  else if (dx >= threshold) delta = -1;
  else {
    // Flick: fast swipe flips even if you didn't reach half.
    // dx < 0 => swipe left => next (delta=+1)
    // dx > 0 => swipe right => prev (delta=-1)
    const vx = swipe.vx;
    if (Math.abs(dx) >= FLICK_MIN_DISTANCE_PX && Math.abs(vx) >= FLICK_VELOCITY_PX_PER_MS) {
      delta = vx < 0 ? 1 : -1;
    }
  }

  if (delta === 0) {
    // Snap back
    swipe.animating = true;
    swipe.animToken += 1;
    const token = swipe.animToken;
    swipe.animDelta = 0;
    setSlideTransform(0, { animate: true });
    swipe.timer = window.setTimeout(() => {
      if (token !== swipe.animToken) return;
      setSlideTransform(0, { animate: false });
      swipe.dx = 0;
      swipe.vx = 0;
      swipe.animating = false;
      swipe.timer = null;
    }, SLIDE_ANIM_MS + 20);
    return;
  }

  // Complete slide to the next/prev image
  animateBy(delta);
}

stage.addEventListener("pointerup", (e) => {
  if (!zoomState.pointers.has(e.pointerId)) return;
  try {
    stage.releasePointerCapture(e.pointerId);
  } catch {
    // ignore
  }

  removeZoomPointer(e);

  if (zoomState.mode === "swipe" && swipe.pointerId === e.pointerId) {
    finishSwipe();
    zoomState.mode = "none";
    e.preventDefault();
    return;
  }

  // End pan/pinch
  if (zoomState.pointers.size === 0) {
    stage.classList.remove("dragging");
    if (zoomState.zoom <= 1.02) resetZoom();
    else snapPanBack();
    zoomState.mode = "none";
  } else if (zoomState.pointers.size === 1) {
    // If one finger remains after pinch, continue panning if zoomed in
    const remaining = zoomState.pointers.values().next().value;
    if (zoomState.zoom > 1.01 && remaining) {
      zoomState.mode = "pan";
      zoomState.lastX = remaining.x;
      zoomState.lastY = remaining.y;
    } else {
      resetZoom();
      zoomState.mode = "swipe";
      // user can continue with a new touch for swipe
      swipe.active = false;
      swipe.pointerId = null;
    }
  }

  // Double-tap (only when gesture ended with a single pointer and no drag)
  if (zoomState.pointers.size === 0 && e.target && e.target.closest && e.target.closest(".overlay-photo")) {
    const now = performance.now();
    const dt = now - zoomState.lastTapAt;
    const dx = e.clientX - zoomState.lastTapX;
    const dy = e.clientY - zoomState.lastTapY;
    const closeEnough = (dx * dx + dy * dy) < (28 * 28);

    if (!swipe.suppressClick && dt > 0 && dt < 280 && closeEnough) {
      // Trigger zoom toggle
      swipe.suppressClick = true;
      zoomState.lastTapAt = 0;
      toggleZoomAt(e.clientX, e.clientY);
      e.preventDefault();
      return;
    }

    // store tap
    zoomState.lastTapAt = now;
    zoomState.lastTapX = e.clientX;
    zoomState.lastTapY = e.clientY;
  }

  e.preventDefault();
}, { capture: true });

stage.addEventListener("pointercancel", (e) => {
  try {
    stage.releasePointerCapture(e.pointerId);
  } catch {
    // ignore
  }
  if (zoomState.mode === "swipe" && swipe.pointerId === e.pointerId) {
    finishSwipe();
  }
  removeZoomPointer(e);
  stage.classList.remove("dragging");
  if (zoomState.zoom <= 1.02) resetZoom();
  zoomState.mode = "none";
  e.preventDefault();
}, { capture: true });

stage.addEventListener("click", (e) => {
  // close only when clicking on the dark background (not on the image / buttons)
  if (swipe.suppressClick) {
    swipe.suppressClick = false;
    return;
  }
  if (e.target && e.target.closest && e.target.closest(".overlay-photo")) return;
  closeOverlay();
});

// Desktop: double click to zoom
stage.addEventListener("dblclick", (e) => {
  if (!overlay.classList.contains("active")) return;
  if (e.target && e.target.closest && e.target.closest(".overlay-photo")) {
    swipe.suppressClick = true;
    toggleZoomAt(e.clientX, e.clientY);
    e.preventDefault();
  }
}, { capture: true });

// Re-measure base size when the current image loads (important for correct pan bounds)
overlayCurrImg.addEventListener("load", () => requestAnimationFrame(updateZoomBaseSize));

// Кнопка закрытия всегда поверх изображения
closeBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  closeOverlay();
});

// Не закрывать при клике по счётчику
counter.addEventListener("click", (e) => e.stopPropagation());
</script>

</body>
</html>
