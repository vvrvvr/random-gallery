<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Gallery</title>

<style>
  html, body {
    height: 100%;
  }

  body {
    margin: 20px;
    font-family: Arial, sans-serif;
    background: #fff;
  }

  :root {
    --gap: 8px;
    --tile: clamp(140px, 18vw, 220px);
  }

  /* Adaptive mosaic grid (Yandex Disk-ish) */
  #gallery {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--tile), 1fr));
    /* Fill the viewport height with photos (no big empty area at the bottom) */
    height: calc(100vh - 40px);
    grid-auto-rows: minmax(calc(var(--tile) * 0.75), 1fr);
    grid-auto-flow: dense;
    gap: var(--gap);
    align-content: stretch;
  }

  .tile {
    position: relative;
    overflow: hidden;
  }

  .tile.wide {
    grid-column: span 2;
  }

  .tile.tall {
    grid-row: span 2;
  }

  /* Text tile (behaves like a tile, but isn't selectable / not part of overlay) */
  .tile.text {
    background: #f6f7f9;
    border: 1px solid rgba(0,0,0,0.08);
    padding: 16px 16px 14px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    gap: 10px;
    overflow: hidden;
    cursor: default;
  }

  .tile.text .text-title {
    margin: 0;
    font-size: 18px;
    line-height: 1.2;
    letter-spacing: 0.01em;
  }

  .tile.text .text-body {
    margin: 0;
    font-size: 14px;
    line-height: 1.45;
    color: rgba(0,0,0,0.74);
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
  }

  img.thumb {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 0;
    cursor: pointer;
    display: block;
  }

  @media (max-width: 420px) {
    #gallery {
      grid-template-columns: 1fr;
      grid-auto-rows: clamp(160px, 48vw, 240px);
    }

    .tile.wide,
    .tile.tall {
      grid-column: span 1;
      grid-row: span 1;
    }
  }

  /* Overlay */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.18s ease;
  }

  .overlay.active {
    opacity: 1;
    visibility: visible;
  }

  /* Изображение */
  .overlay img {
    max-width: 95vw;
    max-height: 95vh;
    width: auto;
    height: auto;
    object-fit: contain;
    transform: scale(0.96);
    transition: transform 0.18s ease;
    cursor: pointer;
    z-index: 1; /* ниже кнопок */
  }

  .overlay.active img {
    transform: scale(1);
  }

  /* Навигационные кнопки */
  .nav-btn {
    position: fixed; /* фиксируем относительно окна */
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    background: rgba(0,0,0,0.3);
    border: none;
    padding: 10px 15px;
    cursor: pointer;
    user-select: none;
    border-radius: 4px;
    z-index: 2; /* выше изображения */
  }

  .nav-btn:hover {
    background: rgba(255,255,255,0.2);
  }

  #prevBtn { left: 10px; }
  #nextBtn { right: 10px; }
</style>
</head>

<body>

<div id="gallery"></div>

<div class="overlay" id="overlay">
  <button class="nav-btn" id="prevBtn">&#10094;</button>
  <img id="overlayImg">
  <button class="nav-btn" id="nextBtn">&#10095;</button>
</div>

<script>
const totalImages = 70;
const imagesToShow = 10;

let saved = localStorage.getItem("myImages");
let selectedImages;

if (saved) {
  selectedImages = JSON.parse(saved);
} else {
  let all = Array.from({length: totalImages}, (_, i) => i + 1);
  all.sort(() => 0.5 - Math.random());
  selectedImages = all.slice(0, imagesToShow);
  localStorage.setItem("myImages", JSON.stringify(selectedImages));
}

const overlay = document.getElementById("overlay");
const overlayImg = document.getElementById("overlayImg");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const gallery = document.getElementById("gallery");

let currentIndex = 0;

function pickUniqueIndices(n, k) {
  const indices = Array.from({ length: n }, (_, i) => i);
  indices.sort(() => Math.random() - 0.5);
  return indices.slice(0, Math.max(0, Math.min(k, n)));
}

// A few subtle accents: some tiles a bit wider or taller (not huge differences)
const tilesOnScreen = imagesToShow + 1; // 10 photos + 1 text tile
const maxWide = Math.max(1, Math.round(tilesOnScreen * 0.2));
const maxTall = Math.max(1, Math.round(tilesOnScreen * 0.15));
const picked = pickUniqueIndices(tilesOnScreen, maxWide + maxTall);
const wideSet = new Set(picked.slice(0, maxWide));
const tallSet = new Set(picked.slice(maxWide));

// Создаём превьюшки
selectedImages.forEach((num, index) => {
  let tile = document.createElement("div");
  tile.className = "tile";
  if (wideSet.has(index)) tile.classList.add("wide");
  else if (tallSet.has(index)) tile.classList.add("tall");

  let img = document.createElement("img");
  img.src = "images/" + num + ".jpg";
  img.className = "thumb";
  img.loading = "lazy";
  img.decoding = "async";

  img.addEventListener("click", () => {
    currentIndex = index;
    overlayImg.src = img.src;
    overlay.classList.add("active");
    overlay.style.visibility = "visible";
  });

  tile.appendChild(img);
  gallery.appendChild(tile);
});

// 11-я "плитка" — текст (не кликается, не попадает в оверлей/листание)
(() => {
  const index = tilesOnScreen - 1;
  const tile = document.createElement("div");
  tile.className = "tile text";
  if (wideSet.has(index)) tile.classList.add("wide");
  else if (tallSet.has(index)) tile.classList.add("tall");

  const h = document.createElement("h3");
  h.className = "text-title";
  h.textContent = "Заметка";

  const p = document.createElement("p");
  p.className = "text-body";
  p.textContent =
    "Это текстовый блок примерно на 200 символов: он участвует в раскладке как обычная плитка, но не открывается в просмотрщике. Здесь можно писать описание, заметку или подпись к подборке снимков.";

  tile.appendChild(h);
  tile.appendChild(p);
  gallery.appendChild(tile);

  // Keep title size stable, but scale the note text down when the tile is smaller.
  const NOTE_BASE_PX = 14;
  const NOTE_MIN_PX = 10;
  const NOTE_STEP_PX = 0.5;

  function fitNoteText() {
    // Reset to base before fitting
    let size = NOTE_BASE_PX;
    p.style.fontSize = `${size}px`;

    // If it overflows, shrink until it fits or we hit minimum.
    // (Only one element, so a small loop is fine.)
    let guard = 0;
    while (p.scrollHeight > p.clientHeight && size > NOTE_MIN_PX && guard < 30) {
      size = Math.max(NOTE_MIN_PX, size - NOTE_STEP_PX);
      p.style.fontSize = `${size}px`;
      guard += 1;
    }
  }

  // Initial fit after layout
  requestAnimationFrame(fitNoteText);

  // Refit on resize (grid reflow / window resize)
  if ("ResizeObserver" in window) {
    const ro = new ResizeObserver(() => fitNoteText());
    ro.observe(tile);
  } else {
    window.addEventListener("resize", fitNoteText);
  }
})();

// Функция переключения фото
function showImage(index) {
  currentIndex = (index + imagesToShow) % imagesToShow; // циклически
  overlayImg.src = "images/" + selectedImages[currentIndex] + ".jpg";
}

// Кнопки навигации
prevBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  showImage(currentIndex - 1);
});

nextBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  showImage(currentIndex + 1);
});

// Закрытие фото с плавным исчезновением
overlayImg.addEventListener("click", () => {
  overlay.classList.remove("active");
  setTimeout(() => {
    if (!overlay.classList.contains("active")) {
      overlay.style.visibility = "hidden";
    }
  }, 180); // совпадает с transition
});
</script>

</body>
</html>
